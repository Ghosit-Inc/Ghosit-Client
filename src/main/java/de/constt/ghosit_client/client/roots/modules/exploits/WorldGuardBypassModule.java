package de.constt.ghosit_client.client.roots.modules.exploits;

import de.constt.ghosit_client.client.annotations.ModuleInfoAnnotation;
import de.constt.ghosit_client.client.roots.implementations.CategoryImplementation;
import de.constt.ghosit_client.client.roots.implementations.ModuleImplementation;
import net.minecraft.client.MinecraftClient;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
import net.minecraft.util.math.Vec3d;

import java.util.Objects;

@ModuleInfoAnnotation(
        name = "WorldGuard Bypass",
        description = "Tries to bypass the passthrough flase flag in a worldguard region",
        category = CategoryImplementation.Categories.EXPLOITS,
        internalModuleName = "worldguardbypass"
)

public class WorldGuardBypassModule extends ModuleImplementation {
    final double MAX_DELTA = 0.05001;
    int flyingTimer = 0;
    MinecraftClient client = MinecraftClient.getInstance();

    @Override
    public void tick() {
        if (client.player == null || client.world == null) return;

        client.player.setVelocity(0, 0, 0);

        if (++flyingTimer > 20) {
            Vec3d pos = client.player.getPos();
            pos = pos.add(0, -MAX_DELTA, 0);

            client.player.setPosition(pos.x, pos.y, pos.z);
            // Position + on ground packet
            client.getNetworkHandler().sendPacket(
                    new PlayerMoveC2SPacket.PositionAndOnGround(
                            pos.x,
                            pos.y,
                            pos.z,
                            true,
                            false
                    )
            );


            client.getNetworkHandler().sendPacket(
                    new PlayerMoveC2SPacket.Full(
                            pos.x + 1337.0,
                            pos.y + 1337.0,
                            pos.z + 1337.0,
                            client.player.getYaw(),
                            client.player.getPitch(),
                            true,
                            false
                    )
            );


            flyingTimer = 0;
        } else {
            Vec3d vec = getMovementVec();
            assert vec != null;

            if (vec.length() > 0) {
                if (!(vec.x == 0 && vec.z == 0)) {
                    double moveAngle = Math.atan2(vec.x, vec.z) + Math.toRadians(client.player.getYaw() + 90);
                    double x = Math.cos(moveAngle);
                    double z = Math.sin(moveAngle);
                    vec = new Vec3d(x, vec.y, z);
                }

                vec = vec.multiply(MAX_DELTA);

                Vec3d newPos = new Vec3d(client.player.getX() + vec.x, client.player.getY() + vec.y, client.player.getZ() + vec.z);
                if (collides(newPos)) return;

                boolean extra = false;
                if (client.options.sprintKey.isPressed()) {
                    while (inSameBlock(newPos.add(vec.multiply(1.5)), new Vec3d(client.player.getLastRenderPos().x, client.player.getLastRenderPos().y, client.player.getLastRenderPos().z)) &&
                            !collides(newPos.add(vec.multiply(1.5)))) {
                        newPos = newPos.add(vec);
                        extra = true;
                    }
                }

                client.player.setPosition(newPos);

                PlayerMoveC2SPacket smallMovePacket = new PlayerMoveC2SPacket.Full(
                        new Vec3d(client.player.getX(), client.player.getY(), client.player.getZ()),
                        client.player.getYaw(),
                        client.player.getPitch(),
                        client.player.isOnGround(),
                        false // horizontalCollision false usually
                );

                Objects.requireNonNull(client.getNetworkHandler()).sendPacket(smallMovePacket);

                if (!extra) {
                    PlayerMoveC2SPacket farPacket = new PlayerMoveC2SPacket.Full(
                            new Vec3d(
                                    client.player.getX() + 1337.0,
                                    client.player.getY() + 1337.0,
                                    client.player.getZ() + 1337.0
                            ),
                            client.player.getYaw(),
                            client.player.getPitch(),
                            client.player.isOnGround(),
                            false
                    );

                    client.getNetworkHandler().sendPacket(farPacket);
                }

            }
        }
    }

    public static boolean inSameBlock(Vec3d vector, Vec3d other) {
        return other.x >= Math.floor(vector.x) && other.x <= Math.ceil(vector.x) &&
                other.y >= Math.floor(vector.y) && other.y <= Math.ceil(vector.y) &&
                other.z >= Math.floor(vector.z) && other.z <= Math.ceil(vector.z);
    }

    public static boolean collides(Vec3d pos) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.player == null || client.world == null) return false;

        return !client.world.isSpaceEmpty(client.player, client.player.getBoundingBox().offset(pos.subtract(client.player.getPos())));
    }

    public static Vec3d getMovementVec() {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.player == null) return null;

        Vec3d vec = new Vec3d(0, 0, 0);

        if (client.player.input.playerInput.jump()) {
            vec = vec.add(new Vec3d(0, 1, 0));
        } else if (client.player.input.playerInput.sneak()) {
            vec = vec.add(new Vec3d(0, -1, 0));
        } else {
            if (client.player.input.playerInput.forward()) {
                vec = vec.add(new Vec3d(0, 0, 1));
            }
            if (client.player.input.playerInput.right()) {
                vec = vec.add(new Vec3d(1, 0, 0));
            }
            if (client.player.input.playerInput.backward()) {
                vec = vec.add(new Vec3d(0, 0, -1));
            }
            if (client.player.input.playerInput.left()) {
                vec = vec.add(new Vec3d(-1, 0, 0));
            }
        }

        return vec.normalize();
    }
}
